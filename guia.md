. Arquitectura del Sistema (Blueprint)
El sistema se divide en tres capas que Antigravity debe coordinar:Capa de Entrada (Ingress): API REST protegida en Render que recibe peticiones en formato universal (OpenAI Compatible).Capa de Lógica (Router/Brain): Código Python que gestiona el flujo de "cascada" (fallback) entre modelos gratuitos y de pago.Capa de Persistencia (Memory): Conexión con Supabase para almacenamiento de sesiones y registros de uso.2. Configuración de Infraestructura y VariablesAntigravity debe asegurar que las siguientes "llaves" estén configuradas en el entorno de Render:Proveedores de IA:OPENROUTER_API_KEY (Acceso a modelos :free).GEMINI_API_KEY (Respaldo directo de Google AI Studio).ANTHROPIC_API_KEY (Para tareas de alta complejidad).Base de Datos (Supabase):SUPABASE_URLSUPABASE_SERVICE_ROLE_KEY (Para gestión de datos).Seguridad:CEREBRO_API_TOKEN (Tu clave privada para usar el sistema).3. Lógica de "Cascada de Resiliencia" (Algoritmo de Selección)El plan para el código debe seguir este orden de ejecución ante cada pregunta:Paso 1: Recuperación de Contexto. Consultar en Supabase los últimos $N$ mensajes del session_id proporcionado.Paso 2: Intento Gratuito (Tier 1). Llamar a OpenRouter usando modelos sin costo (google/gemini-2.0-flash-exp:free o deepseek/deepseek-r1:free).Paso 3: Gestión de Errores (Fallback). Si el Tier 1 devuelve error (Rate limit o Créditos), saltar automáticamente a la API directa de Gemini.Paso 4: Modo Potencia (Opcional). Si el usuario envía un parámetro priority: high, ignorar los anteriores y usar Claude 3.5 Sonnet.Paso 5: Escritura en Memoria. Guardar la respuesta del modelo seleccionado en Supabase antes de entregarla al usuario.4. Esquema de Datos en SupabasePara que Antigravity sepa qué tablas crear en Supabase:Tabla interacciones:id (UUID), created_at (Timestamp).session_id (String) -> Para agrupar conversaciones.role (User/Assistant).content (Text).model_used (String) -> Para auditoría.Tabla config_usuario:Preferencias de modelo por defecto y límites de tokens diarios.5. Implementación en Render (Deployment)El plan de despliegue consiste en:Contenedorización: Usar un Dockerfile ligero basado en python:3.11-slim.Servidor de Aplicaciones: Utilizar Uvicorn con FastAPI para manejar múltiples peticiones asíncronas de n8n o scripts externos simultáneamente.Health Checks: Configurar un endpoint /health para que Render sepa que el "cerebro" está activo.